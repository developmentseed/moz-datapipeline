'use strict';
import fs from 'fs-extra';
import path from 'path';
import Promise from 'bluebird';

import { dataToCSV, addScaledScore, getRoadClass, getRoadCondition, getSurface } from '../utils/utils';
import { tStart, tEnd, initLog } from '../utils/logging';

/**
 * Calculates the cost of repairing or rebuilding bridges, culverts and road
 * surface when a flood occurs.
 *
 * It relies on two datasets:
 *   1. a GeoJSON with road network data
 *   2. flood depth values for each road segment
 *
 * Usage:
 *  $node ./scripts/vulnerability
 *
 */

// //////////////////////////////////////////////////////////
// Config Vars

const TMP_DIR = path.resolve(__dirname, '../../.tmp');
const LOG_DIR = path.resolve(__dirname, '../../log/vulnerability');

const RN_FILE = path.resolve(TMP_DIR, 'roadnetwork.geojson');
const OUTPUT_INDICATOR_FILE = path.resolve(TMP_DIR, `indicator-flood-ead.csv`);

const clog = initLog(`${LOG_DIR}/log-${Date.now()}.txt`);

clog('Loading Road Network');
const ways = fs.readJsonSync(RN_FILE).features;

// Repair cost bridges and culverts.
// Bridges is cost per meter, culvert is cost per repair
const repairCostBC = {
  'bridge': {
    'paved': {
      'primary': 44000,
      'secondary': 44000,
      'tertiary': 44000,
      'vicinal': 44000
    },
    'unpaved': {
      'primary': 44000,
      'secondary': 44000,
      'tertiary': 44000,
      'vicinal': 44000
    }
  },
  'culvert': {
    'paved': {
      'primary': 10000,
      'secondary': 10000,
      'tertiary': 10000,
      'vicinal': 10000
    },
    'unpaved': {
      'primary': 10000,
      'secondary': 10000,
      'tertiary': 10000,
      'vicinal': 10000
    }
  }
};

// Repair cost of a road per kilometer
const repairCostRoad = {
  'low': {
    'paved': {
      'primary': 2000,
      'secondary': 2000,
      'tertiary': 2000,
      'vicinal': 2000
    },
    'unpaved': {
      'primary': 15000,
      'secondary': 15000,
      'tertiary': 15000,
      'vicinal': 15000
    }
  },
  'medium': {
    'paved': {
      'primary': 4000,
      'secondary': 4000,
      'tertiary': 4000,
      'vicinal': 4000
    },
    'unpaved': {
      'primary': 27000,
      'secondary': 27000,
      'tertiary': 27000,
      'vicinal': 27000
    }
  },
  'high': {
    'paved': {
      'primary': 20000,
      'secondary': 20000,
      'tertiary': 20000,
      'vicinal': 20000
    },
    'unpaved': {
      'primary': 55000,
      'secondary': 55000,
      'tertiary': 55000,
      'vicinal': 55000
    }
  }
};

// Condition rate of the bridge or culvert. To be applied to the damage to
// account for the fact that the condition of the structure will influence how
// much damage it takes.
const bridgeConditionRates = {
  'poor': 0.3,
  'fair': 0.5,
  'good': 0.7
};

// The return periods of the flood data
const returnPeriods = [ 5, 10, 20, 50, 75, 100, 200, 250, 500, 1000 ];

const designStandard = {
  'bridge': 100,
  'culvert': 20
};

/**
 * Calculate expected annual damage (EAD) for damages, using trapezoidal rule
 *
 * @param  {Array} damages            Array with values for damages for the
 *                                    return periods
 *
 * @return {Integer}
 */
function calculateEAD (damages) {
  let totalDamage = 0;
  for (let idx = 0; idx < returnPeriods.length - 1; idx++) {
    totalDamage += (1 / returnPeriods[idx] - 1 / returnPeriods[idx + 1]) * (damages[idx] + damages[idx + 1]);
  }
  return totalDamage / 2;
}

/**
 * Calculate damage to a bridges or culvert for a single return period.
 * Damage is modeled as a % of total replacement cost based on the difference
 * between the observed water level and the water level the structure was
 * designed for.
 *
 * @param  {Object} bridge            Object with type (culvert / bridge) and length.
 * @param  {Number} floodDepth        Water level in meter for a climate change
 *                                    scenario / return period
 * @param  {Number} waterLevelDesign  Water level design standard in meter
 * @param  {Object} road              Object with road properties
 *
 * @return {Integer}
 */
function calculateBCDamage (bridge, floodDepth, waterLevelDesign, road) {
  let drainageCapacity = 0.7;
  // Calculating the bridge condition rate from the road
  let conditionRate = bridgeConditionRates[road.condition];

  // Repair costs for bridge a per meter, for culverts per unit
  let length = bridge.type === 'bridge' ? Number(bridge.length) : 1;
  let replacementCost = repairCostBC[bridge.type][road.surface][road.class] * length;

  // Return 0 if damage is negative. Happens when waterLevel doesn't reach
  // above waterLevelDesign * drainageCapacity
  return Math.max(0, (floodDepth - waterLevelDesign * drainageCapacity) * 1 / conditionRate * replacementCost);
}

/**
 * Calculate expected annual damage (EAD) for a bridge, for a series of return
 * periods.
 *
 * @param  {Object} bridge            Object with bridge or culvert.
 * @param  {Object} road              Object with road properties
 *
 * @return {Integer}
 */
function calculateBCEAD (bridge, road) {
  // Array with damage per period
  let damages = returnPeriods.map((period, i) => {
    let floodDepth = road.flood_depths[i];

    // Check which return period this type of structure was built for.
    let rpIndex = returnPeriods.indexOf(designStandard[bridge.type]);
    let waterLevelDesign = road.flood_depths[rpIndex];

    return calculateBCDamage(bridge, floodDepth, waterLevelDesign, road);
  });
  return calculateEAD(damages);
}

/**
 * Calculate damage to a road segment for a single return period.
 * Damage costs on road surface is based on 3 thresholds of water above surface
 * Roads are assumed to built at ground level (no embankment).
 *
 * @param  {Object} road               Object with road properties
 * @param  {Integer} rpIndex           Index of the return period
 *
 * @return {Integer}
 */
function calculateRoadDamage (road, rpIndex) {
  let floodDepth = road.flood_depths[rpIndex];
  let floodLength = road.flood_lengths[rpIndex];

  // No damage if waterlevel is below 0.2 meters
  if (floodDepth < 0.2) return 0;

  let severity = 'low';
  if (floodDepth > 0.5 && floodDepth <= 1.5) severity = 'medium';
  if (floodDepth > 1.5) severity = 'high';

  return floodLength * repairCostRoad[severity][road.surface][road.class];
}

/**
 * Calculate expected annual damage (EAD) for a road, for a series of return
 * periods.
 *
 * @param  {Object} road              Object with road properties
 *
 * @return {Integer}
 */
function calculateRoadEAD (road) {
  // Array with damage per period
  let damages = returnPeriods.map((period, i) => calculateRoadDamage(road, i));

  return calculateEAD(damages);
}

/**
 * Runs the analysis, calculating the Estimated Annual Damage of a road segment
 * due to flood events.
 *
 * @param  {Array} ways         Array with GeoJSON objects for roads
 *
 * @return Promise{}            Resolves when file was written.
 */
async function run (ways) {
  const wayValues = ways.map(way => {
    // Set sensible defaults.
    way = { ...way,
      properties: { ...way.properties,
        class: getRoadClass(way),
        condition: getRoadCondition(way),
        surface: getSurface(way)
      }
    };

    // Calculate total damage to bridges and culverts on this way.
    let bridgeDamage = way.properties.bridges
      .map(bridge => calculateBCEAD(bridge, way.properties))
      .reduce((a, b) => a + b, 0);

    // Calculate road damage.
    let roadDamage = calculateRoadEAD(way.properties);

    return {
      way_id: way.properties.NAME,
      value: Math.floor(bridgeDamage + roadDamage)
    };
  });

  // calculate scaled score
  const csv = await dataToCSV(addScaledScore(wayValues));
  return fs.writeFile(OUTPUT_INDICATOR_FILE, csv);
}

(async function main () {
  try {
    await Promise.all([
      fs.ensureDir(TMP_DIR),
      fs.ensureDir(LOG_DIR)
    ]);

    tStart(`Total run time`)();
    await run(ways);
    tEnd(`Total run time`)();
  } catch (e) {
    console.log(e);
  }
}());
