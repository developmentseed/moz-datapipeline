'use strict';
import fs from 'fs-extra';
import path from 'path';
import Promise from 'bluebird';
import bbox from '@turf/bbox';
import lineSplit from '@turf/line-split';
import pointWithinPolygon from '@turf/points-within-polygon';
import { point } from '@turf/helpers';
import length from '@turf/length';

import { prepTree, dataToCSV, dataFromCSV } from '../utils/utils';
import { tStart, tEnd, initLog } from '../utils/logging';

/**
 * Calculates the cost of repairing or rebuilding bridges, culverts and road
 * surface when a flood occurs.
 *
 * It relies on two datasets:
 *   1. a GeoJSON with road network data
 *   2. flood depth values for each road segment
 *
 * Usage:
 *  $node ./scripts/vulnerability
 *
 */

// //////////////////////////////////////////////////////////
// Config Vars

const OUTPUT_DIR = path.resolve(__dirname, '../../.tmp');
const LOG_DIR = path.resolve(__dirname, '../../log/vulnerability');

const RN_FILE = path.resolve(OUTPUT_DIR, 'roadnetwork.geojson');
const BRIDGE_FILE = path.resolve(OUTPUT_DIR, 'bridges.geojson');
const OUTPUT_INDICATOR_FILE = path.resolve(OUTPUT_DIR, `indicator-vulnerability.csv`);

const clog = initLog(`${LOG_DIR}/log-${Date.now()}.txt`);

clog('Loading Road Network');
const ways = fs.readJsonSync(RN_FILE).features;
clog('Loading Bridges and Culverts');
const bridges = fs.readJsonSync(BRIDGE_FILE).features;
clog('Loading Flood Data');
const floodData = fs.readFileSync(path.resolve(__dirname, './roadnetwork_stats-sample.csv'));

// Water Level design, from the design standard of 20 yrs for culverts and 100
// yr for bridges
const waterLevelDesign = {
  bridge: 1,
  culvert: 1
}

// Repair cost bridges and culverts.
// Bridges is cost per meter, culvert is cost per repair
const repairCostBC = {
  'bridge': {
    'paved': {
      'primary': 40000,
      'secondary': 40000,
      'tertiary': 40000,
      'unclassified': 40000
    },
    'unpaved': {
      'primary': 40000,
      'secondary': 40000,
      'tertiary': 40000,
      'unclassified': 40000
    }
  },
  'culvert': {
    'paved': {
      'primary': 10000,
      'secondary': 10000,
      'tertiary': 10000,
      'unclassified': 10000
    },
    'unpaved': {
      'primary': 10000,
      'secondary': 10000,
      'tertiary': 10000,
      'unclassified': 10000
    }
  }
}

function getRoadClass (road) {
  let roadClass = road.properties.ROAD_CLASS.toLowerCase()

  if (roadClass === 'N/A') return 'secondary'
  if (roadClass === 'vicinal') return 'unclassified'
  return roadClass
}

function getSurface (road) {
  let surfType = road.properties.SURF_TYPE.toLowerCase();
  if (surfType === 'paved' || surfType === 'unpaved') return surfType
  return 'unpaved'
}

/**
 * Calculate damage to Bridges and Culverts.
 * Damage is modeled as a % of total replacement cost based on the difference
 * between the observed water level and the water level the structure was
 * designed for.
 *
 * @param  {Object} bridge      GeoJSON object with bridge or culvert.
 * @param  {Number} waterLevel  Water level in meter for a climate change 
 *                              scenario / return period
 * @param  {String} roadClass   Class of the road
 * @param  {String} roadSurface Surface type of the road
 *
 * @return {Integer}            Resolves when file was written.
 */
function calculateBCDamage(bridge, waterLevel, roadClass, roadSurface) {
  let b = bridge.properties;

  // TMP
  let drainageCapacity = 0.7
  let conditionRate = 0.5

  // Repair costs for bridge a per meter, for culverts per unit
  let length = b.type === 'bridge' ? Number(b.Over_Length) : 1;
  let replacementCost = repairCostBC[b.type][roadSurface][roadClass] * length;

  return (waterLevel - waterLevelDesign[b.type] * drainageCapacity) * 1 / conditionRate * replacementCost
}

/**
 * Calculate damage to roads.
 * Damage costs on road surface is based on 3 thresholds of water above surface
 * Roads are assumed to built at ground level (no embankment).
 *
 * @param  {Array} way          GeoJSON feature object with way
 * @param  {Number} waterLevel  Water level in meter for a climate change 
 *                              scenario / return period
 *
 * @return {Integer}            Resolves when file was written.
 */
function calculateRoadDamage(way, waterLevel) {
  return 10
}

/**
 * Runs the analysis, calculating a weighted score for each way.
 *
 * @param  {Array} ways         Road netowrk ways.
 * @param  {Object} tree        Rbush tree.
 * @param  {String} indProperty Property to get value from.
 *
 * @return Promise{}            Resolves when file was written.
 */
async function run (ways, bridges, floods) {
  const wayScore = ways.map(way => {
    // Set sensible defaults
    let roadClass = getRoadClass(way)
    let roadSurface = getSurface(way)

    // TMP. make this work across floods and scenarios
    let maxFlood = floods.find(f => f.fid === way.properties.NAME)[' max']

    // calculate total damage to bridges and culverts on this way
    let bridgeDamage = bridges
      .filter(bridge => bridge.properties.roadSegmentID === way.properties.NAME)
      .map(bridge => calculateBCDamage(bridge, maxFlood, roadsClass, roadSurface))
      .reduce((a, b) => a + b, 0)

    // calculate road damage

    return {
      way_id: way.properties.NAME,
      value: bridgeDamage,
      score: bridgeDamage
    };
  })

  // calculate scaled score

  const csv = await dataToCSV(wayScore);
  return fs.writeFile(OUTPUT_INDICATOR_FILE, csv);
}

(async function main () {
  try {
    await Promise.all([
      fs.ensureDir(OUTPUT_DIR),
      fs.ensureDir(LOG_DIR)
    ]);

    const floods = await dataFromCSV(floodData)

    tStart(`Total run time`)();
    await run(ways, bridges, floods);
    tEnd(`Total run time`)();

  } catch (e) {
    console.log(e);
  }
}());
