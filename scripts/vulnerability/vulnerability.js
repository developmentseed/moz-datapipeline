'use strict';
import fs from 'fs-extra';
import fetch from 'node-fetch';
import path from 'path';
import Promise from 'bluebird';

import { dataToCSV, addScaledScore, getRoadClass, getRoadCondition, getSurface } from '../utils/utils';
import { tStart, tEnd, initLog } from '../utils/logging';

/**
 * Calculates the cost of repairing or rebuilding bridges, culverts and road
 * surface when a flood occurs.
 *
 * It relies on two datasets:
 *   1. a GeoJSON with road network data
 *   2. flood depth values for each road segment
 *
 * Usage:
 *  $node ./scripts/vulnerability
 *
 */

// //////////////////////////////////////////////////////////
// Config Vars

const TMP_DIR = path.resolve(__dirname, '../../.tmp');
const OUTPUT_DIR = path.resolve(__dirname, '../../output');
const LOG_DIR = path.resolve(__dirname, '../../log/vulnerability');

const RN_FILE = path.resolve(TMP_DIR, 'roadnetwork.geojson');
const BRIDGE_FILE = path.resolve(TMP_DIR, 'bridges.geojson');
const OUTPUT_INDICATOR_FILE = path.resolve(OUTPUT_DIR, `indicator-flood-ead.csv`);

const FLOOD_FILE = 'https://s3.amazonaws.com/mozambique-road-planning/fluvial-pluvial/current/roadnetwork_stats.json';

const clog = initLog(`${LOG_DIR}/log-${Date.now()}.txt`);

clog('Loading Road Network');
const ways = fs.readJsonSync(RN_FILE).features;
clog('Loading Bridges and Culverts');
const bridges = fs.readJsonSync(BRIDGE_FILE).features;

// Repair cost bridges and culverts.
// Bridges is cost per meter, culvert is cost per repair
const repairCostBC = {
  'bridge': {
    'paved': {
      'primary': 40000,
      'secondary': 40000,
      'tertiary': 40000,
      'vicinal': 40000
    },
    'unpaved': {
      'primary': 40000,
      'secondary': 40000,
      'tertiary': 40000,
      'vicinal': 40000
    }
  },
  'culvert': {
    'paved': {
      'primary': 10000,
      'secondary': 10000,
      'tertiary': 10000,
      'vicinal': 10000
    },
    'unpaved': {
      'primary': 10000,
      'secondary': 10000,
      'tertiary': 10000,
      'vicinal': 10000
    }
  }
};

// Repair cost of a road per kilometer
const repairCostRoad = {
  'low': {
    'paved': {
      'primary': 2000,
      'secondary': 2000,
      'tertiary': 2000,
      'vicinal': 2000
    },
    'unpaved': {
      'primary': 15000,
      'secondary': 15000,
      'tertiary': 15000,
      'vicinal': 15000
    }
  },
  'medium': {
    'paved': {
      'primary': 4000,
      'secondary': 4000,
      'tertiary': 4000,
      'vicinal': 4000
    },
    'unpaved': {
      'primary': 27000,
      'secondary': 27000,
      'tertiary': 27000,
      'vicinal': 27000
    }
  },
  'high': {
    'paved': {
      'primary': 20000,
      'secondary': 20000,
      'tertiary': 20000,
      'vicinal': 20000
    },
    'unpaved': {
      'primary': 55000,
      'secondary': 55000,
      'tertiary': 55000,
      'vicinal': 55000
    }
  }
};

// Condition rate of the bridge or culvert. To be applied to the damage to
// account for the fact that the condition of the structure will influence how
// much damage it takes.
const bridgeConditionRates = {
  'poor': 0.3,
  'fair': 0.5,
  'good': 0.7
};

// The return periods of the flood data
const returnPeriods = [ 5, 10, 20, 50, 75, 100, 200, 250, 500, 1000 ];

const designStandard = {
  'bridge': 100,
  'culvert': 20
};

/**
 * Calculate expected annual damage (EAD) for damages, using trapezoidal rule
 *
 * @param  {Array} damages            Array with values for damages for the
 *                                    return periods
 *
 * @return {Integer}
 */
function calculateEAD (damages) {
  let totalDamage = 0;
  for (let idx = 0; idx < returnPeriods.length - 1; idx++) {
    totalDamage += (1 / returnPeriods[idx] - 1 / returnPeriods[idx + 1]) * (damages[idx] + damages[idx + 1]);
  }
  return totalDamage / 2;
}

/**
 * Calculate damage to a bridges or culvert for a single return period.
 * Damage is modeled as a % of total replacement cost based on the difference
 * between the observed water level and the water level the structure was
 * designed for.
 *
 * @param  {Object} bridge            GeoJSON object with bridge or culvert.
 * @param  {Number} waterLevel        Water level in meter for a climate change
 *                                    scenario / return period
 * @param  {Number} waterLevelDesign  Water level design standard in meter
 * @param  {Object} roadProps         Properties of the road
 *
 * @return {Integer}
 */
function calculateBCDamage (bridge, waterLevel, waterLevelDesign, roadProps) {
  let b = bridge.properties;
  let drainageCapacity = 0.7;
  // Calculating the bridge condition rate from the road
  let conditionRate = bridgeConditionRates[roadProps.condition];

  // Repair costs for bridge a per meter, for culverts per unit
  let length = b.type === 'bridge' ? Number(b.Over_Length) : 1;
  let replacementCost = repairCostBC[b.type][roadProps.surface][roadProps.class] * length;

  // Return 0 if damage is negative. Happens when waterLevel doesn't reach
  // above waterLevelDesign * drainageCapacity
  return Math.max(0, (waterLevel - waterLevelDesign * drainageCapacity) * 1 / conditionRate * replacementCost);
}

/**
 * Calculate expected annual damage (EAD) for a bridge, for a series of return
 * periods.
 *
 * @param  {Object} bridge            GeoJSON object with bridge or culvert.
 * @param  {Number} floods            Object with water levels for the return
 *                                    periods
 * @param  {Object} roadProps         Properties of the road
 *
 * @return {Integer}
 */
function calculateBCEAD (bridge, floods, roadProps) {
  // Array with damage per period
  let damages = returnPeriods.map(period => {
    let waterLevel = floods[period];
    let waterLevelDesign = floods[designStandard[bridge.properties.type]];

    return calculateBCDamage(bridge, waterLevel, waterLevelDesign, roadProps);
  });
  return calculateEAD(damages);
}

/**
 * Calculate damage to a road segment for a single return period.
 * Damage costs on road surface is based on 3 thresholds of water above surface
 * Roads are assumed to built at ground level (no embankment).
 *
 * @param  {Object} roadProps   Properties of the road
 * @param  {Number} waterLevel  Water level in meter for a climate change
 *                              scenario / return period
 *
 * @return {Integer}
 */
function calculateRoadDamage (roadProps, waterLevel) {
  // No damage if waterlevel is below 0.2 meters
  if (waterLevel < 0.2) return 0;

  let severity = 'low';
  if (waterLevel > 0.5 && waterLevel <= 1.5) severity = 'medium';
  if (waterLevel > 1.5) severity = 'high';

  return roadProps.length * repairCostRoad[severity][roadProps.surface][roadProps.class];
}

/**
 * Calculate expected annual damage (EAD) for a road, for a series of return
 * periods.
 *
 * @param  {Object} roadProps         Properties of the road
 * @param  {Number} floods            Object with water levels for the return
 *                                    periods
 *
 * @return {Integer}
 */
function calculateRoadEAD (roadProps, floods) {
  // Array with damage per period
  let damages = returnPeriods.map(period => calculateRoadDamage(roadProps, floods[period]));

  return calculateEAD(damages);
}

/**
 * Runs the analysis, calculating the Estimated Annual Damage of a road segment
 * due to flood events.
 *
 * @param  {Array} ways         Array with GeoJSON objects for roads
 * @param  {Array} bridges      Array with GeoJSON objects for bridges
 * @param  {Array} floods       Array with max water levels per road
 *
 * @return Promise{}            Resolves when file was written.
 */
async function run (ways, bridges, floods) {
  // console.log(floods)
  const wayValues = ways.map(way => {
    // Set sensible defaults
    let roadProps = {
      'class': getRoadClass(way),
      'condition': getRoadCondition(way),
      'surface': getSurface(way),
      'length': way.properties.length
    };

    // Get the flood values for this road segment
    let roadFloods = floods[way.properties.NAME];

    // calculate total damage to bridges and culverts on this way
    let bridgeDamage = bridges
      .filter(bridge => bridge.properties.roadSegmentID === way.properties.NAME)
      .map(bridge => calculateBCEAD(bridge, roadFloods, roadProps))
      .reduce((a, b) => a + b, 0);

    // calculate road damage
    let roadDamage = calculateRoadEAD(roadProps, roadFloods);

    return {
      way_id: way.properties.NAME,
      value: bridgeDamage + roadDamage
    };
  });

  // calculate scaled score
  const csv = await dataToCSV(addScaledScore(wayValues));
  return fs.writeFile(OUTPUT_INDICATOR_FILE, csv);
}

(async function main () {
  try {
    await Promise.all([
      fs.ensureDir(OUTPUT_DIR),
      fs.ensureDir(LOG_DIR)
    ]);

    const floods = await fetch(FLOOD_FILE).then(res => res.json());

    tStart(`Total run time`)();
    await run(ways, bridges, floods);
    tEnd(`Total run time`)();
  } catch (e) {
    console.log(e);
  }
}());
